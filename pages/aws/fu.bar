

        1, dict untagged : {{'resource id 1': $$$}, 'resource id 2': $$$};
        2, dict aggs : {{tag1: {}}, {tag2: {}}, {tag3: {}}};
        3, float total_blend;
        4, float total_unblend;
        5, float total_tagged_blend;
        6, float total_tagged_unblend;
        7, float total_untagged_blend;
        8, float total_untagged_unblend
    '''
    untagged, aggs = {}, {}
    total_blend, total_unblend, total_tagged_blend, total_tagged_unblend, \
    total_untagged_blend, total_untagged_unblend = 0, 0, 0, 0, 0, 0

    for f in file_paths:
        with open('/tmp/' + f.split('.')[0]+'.csv', 'r', newline = '\n') as csvfile:
            lines = csv.reader(csvfile, delimiter=',', quotechar='"')
            for idx, line in enumerate(lines):
                if idx == 0:
                    col_dict = {}
                    for i, n in enumerate(line):
                        col_dict.update({n.strip(): i})
                    # get index for tags (user:Name, user:Project)
                    idx_tag1, idx_tag2, idx_tag3, idx_tag4 = col_dict['user:Owner'], \
                        col_dict['user:Project'], col_dict['user:ProjectName'], col_dict['user:Name']
                    # get index for datetime
                    idx_dt = col_dict['UsageEndDate']
                    # get index for ProductName
                    idx_pname = col_dict['ProductName']
                    # use quantity has two, blended and unblended
                    idx_dollar_blend = col_dict['BlendedCost']
                    idx_dollar_unblend = col_dict['UnBlendedCost']
                    # for untagged resources
                    idx_resource = col_dict['ResourceId']
                else:
                    # avoid parse the last few lines
                    if line[idx_pname]:
                        if weekChecker(line, idx_dt):
                            tag = untaggedChecker(line, idx_tag1, idx_tag2, idx_tag3, idx_tag4)
                            total_blend += float(line[idx_dollar_blend])
                            total_unblend += float(line[idx_dollar_unblend])
                            if tag:
                                Agg(line, aggs, tag, idx_pname, idx_dollar_blend, idx_dollar_unblend)
                                total_tagged_blend += float(line[idx_dollar_blend])
                                total_tagged_unblend += float(line[idx_dollar_unblend])
                            else:
                                total_untagged_blend += float(line[idx_dollar_blend])
                                total_untagged_unblend += float(line[idx_dollar_unblend])

                                if line[idx_resource] in untagged:
                                    untagged[line[idx_resource]]['total_blended_cost'] += float(line[idx_dollar_blend])
                                    untagged[line[idx_resource]]['total_unblended_cost'] += float(line[idx_dollar_unblend])
                                else:
                                    untagged[line[idx_resource]] = {}
                                    untagged[line[idx_resource]]['total_blended_cost'] = float(line[idx_dollar_blend])
                                    untagged[line[idx_resource]]['total_unblended_cost'] = float(line[idx_dollar_unblend])
        return untagged, aggs, total_blend, total_unblend, \
                total_tagged_blend, total_tagged_unblend,total_untagged_blend, total_untagged_unblend


### friendly print out aggregated cost
def BeautifulPrint(aggs, untagged, is_weekly_summary, *all_costs):
    '''
    give the cost summary generated by func dailyAgg or weeklyAgg, 
    output a reader-friendly string 
    ---
    arg:    
        1, dict aggs : {{tag1: {}}, {tag2: {}}, {tag3: {}}};
        2, dict untagged : {{'resource id 1': $$$}, 'resource id 2': $$$};
        3, bool is_weekly_summary : True/False;
        4, *all_costs : float total_blend, float total_unblend, float total_tagged_blend, 
                        float total_tagged_unblend, float total_untagged_blend, float total_untagged_unblend
    return:
        str cost_summary
    '''
    total_blend, total_unblend, total_tagged_blend, total_tagged_unblend, \
    total_untagged_blend, total_untagged_unblend = [*all_costs]
    cur_time = datetime.datetime.utcnow()
    
    # dictionary for substituting full name with shorter name
    resource_name_map = {'Amazon Elastic Compute Cloud': 'EC2', 'Amazon Simple Storage Service': 'S3'}
    
    cost_agg = ' '
    
    cost_agg += 'TOTAL SPEND: ${} / ${} / ${} (Total/Tagged/Untagged)\n\n'.format(str(round(total_blend, 2)), \
        str(round(total_tagged_blend, 2)), str(round(total_untagged_blend, 2)))
    
    cost_agg += '~ ' * 20
    cost_agg += '\n'
    
    if is_weekly_summary:
        cost_agg += 'HPCC-Cloud WEEKLY spend = ${}(${}) from {} to {} \n'.format(str(round(total_tagged_blend, 2)), \
            str(round(total_untagged_blend, 2)), \
            datetime.datetime.fromtimestamp(int(datetime.datetime.utcnow().timestamp() - 86400.0 * 7)).strftime('%Y-%m-%d %H:%M:%S') + \
            ' UTC to ', cur_time.strftime('%Y-%m-%d %H:%M:%S') + ' UTC ')
    else:
        cost_agg += 'HPCC-Cloud DAILY spend from {} to {} \n'.format(datetime.datetime.fromtimestamp(int(datetime.datetime.utcnow().timestamp()\
            - 86400.0)).strftime('%Y-%m-%d %H:%M:%S') + \
            ' UTC to ', cur_time.strftime('%Y-%m-%d %H:%M:%S') + ' UTC ')
    cost_agg += '~ ' * 20 
    cost_agg += '\n'
    
    
    ### Get usage summary OWNER:Total
    cost_agg += '\nSUMMARY: \n\n'
    
    for k1, v1 in aggs.items():
        cost_agg += '{tag}{blend}\n'.format(tag='Tag: '+k1, 
                                            blend='\t Total: $' + str(round(v1['total_blended_cost'], 2)) + '\n')
    
    cost_agg += '~ ' * 20
    
    
    ### Get usage details
    cost_agg += '\n DETAILS: \n'
                                                                                                     
    for k1, v1 in aggs.items():
        cost_agg += '{tag}{blend}\n'.format(tag='Tag: '+k1, 
                                            blend='\t Total: $' + str(round(v1['total_blended_cost'], 2)) + ', ')
        for k2, v2 in v1.items():
            if k2 not in ['total_blended_cost', 'total_unblended_cost']:
                cost_agg += '{resource} '.format(resource = resource_name_map[k2] if resource_name_map.get(k2) else k2)
                kv3 = list(v2.items())
                cost_agg += '{cost1}\n'.format(cost1 = ': $'+str(round(kv3[0][1], 2)))
                    
        cost_agg += ('-'*10 + '\n')
        
    cost_agg += 'Cost with untagged resources: \n' + '~ ' * 10 + '\n'
    for k, v in untagged.items():
        cost_agg += '{id:}'.format(id = 'ResourceID(if any): ' + k + '\n')
        cost_agg += '{blend}\n'.format(blend='Total: $' + str(round(v['total_blended_cost'], 2)) + ', ')
        cost_agg += '----------\n'
    
    return cost_agg
    

### this is the primary method; it catches S3 update event and fires off the aggregation parser   
def lambda_handler(event, context):
    '''
    catches S3 update event, parse cost info and send cost summary to SSN, 
    which will send email notifications
    ---
    arg:    
        1, list event
        2, list context
    return:
        None
    '''
    print('Debug attempt: Delete this and next line')
    print(event)
    # print("Received event: " + json.dumps(event, indent=2))
    # kilroy mod: change the two keys in the following line
    s3 = boto3.client('s3', aws_access_key_id='XXXXXXXXXXXXXXXXXXXX', aws_secret_access_key='XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX')
    # Get the object from the event and show its content type
    bucket = event['Records'][0]['s3']['bucket']['name']
    key = urllib.parse.unquote_plus(event['Records'][0]['s3']['object']['key'], encoding='utf-8')

    try:
        # list objects
        obj_list = s3.list_objects(Bucket = bucket)
        
        # response2 = s3.get_object(Bucket=bucket, Key = obj_list['Contents'][1]['Key'])
        s3_resource = boto3.resource('s3')
        # s3_resource.Object(bucket, obj_list['Contents'][1]['Key']).download_file('/tmp/'+obj_list['Contents'][1]['Key'])
        files_for_parse = FilePicker(obj_list['Contents'])
        
        print(files_for_parse)

        for f in files_for_parse:
            # print(f)
            # print('\n')
            # print(type(f))
            s3_resource.Object(bucket, f).download_file('/tmp/' + f)
            zip_ref = zipfile.ZipFile('/tmp/'+ f, 'r')
            zip_ref.extractall('/tmp/')
        
        # print(os.listdir('/tmp/'))

        # read and process the most recently updated file
        file_for_daily_agg = files_for_parse[0]

        daily_untagged, daily_aggs, daily_total_blend, daily_total_unblend, daily_total_tagged_blend, \
        daily_total_tagged_unblend, daily_total_untagged_blend, daily_total_untagged_unblend = dailyAgg(file_for_daily_agg.split('.')[0]+'.csv')
        
        # print(aggs)
        # print('---------\n')
        # print(untagged)
        
        cost_agg_str = BeautifulPrint(daily_aggs, daily_untagged, False, daily_total_blend, daily_total_unblend, daily_total_tagged_blend, 
               daily_total_tagged_unblend, daily_total_untagged_blend, daily_total_untagged_unblend)

        if IncludeWeeklySummary():
            weekly_untagged, weekly_aggs, weekly_total_blend, weekly_total_unblend, \
            weekly_total_tagged_blend, weekly_total_tagged_unblend, weekly_total_untagged_blend, \
            weekly_total_untagged_unblend = weeklyAgg(files_for_parse)

            weekly_cost_agg_str = BeautifulPrint(weekly_aggs, weekly_untagged, True, weekly_total_blend, weekly_total_unblend, 
                weekly_total_tagged_blend, weekly_total_tagged_unblend, weekly_total_untagged_blend, weekly_total_untagged_unblend)

            cost_agg_str += ('\n' + '-'*10)
            cost_agg_str += ('\n ~~~ weekly cost summary: ~~~ \n' + weekly_cost_agg_str)

        # kilroy mod: change the access keys in the following line:
        sns = boto3.client('sns', aws_access_key_id='XXXXXXXXXXXXXXXXXXXX', aws_secret_access_key='XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX')

        # kilroy mod: In the response = sns.publish( there are four things to do:
	#   kilroy mod: TopicArn: Change the account number (notice it is 123456789012)
	#   kilroy mod: TopicArn: Verify the region is correct 
	#   kilroy mod: TopicArn: Provide the correct SNS topic name
	#   kilroy mod: Subject: Choose a subject that fits your account
        response = sns.publish(
            TopicArn='arn:aws:sns:us-east-1:123456789012:kilroy_burn_sns',
            Message=cost_agg_str,
            Subject='Kilroy Burn')

	# kilroy mod: Customize the completion message if you like
        return 'kilroy_burn_lambda completed!'

    except Exception as e:
        print(e)
        print('Err in object {} from bucket {}. Ensure bucket exists in same region as this lambda fn.'.format(key, bucket))
        raise e
```




